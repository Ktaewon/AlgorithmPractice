# Sort Algorithm(정렬 알고리즘)
## 알고리즘 정리
* 정렬이란 데이터를 특정한 기준에 따라서 순서대로 나열하는 것.
## 알고리즘 종류
### 1. Bubble Sort(거품 정렬)
* 인접한 두 원소의 대소를 비교하고, 조건에 맞지 않다면 자리를 교환하여 정렬하는 알고리즘
* 방법
    1. 1회전을 수행하면서, 1번째와 2번째, 2번째와 3번째, 이렇게 마지막 - 1 번째와 마지막을 비교해가며 조건에 맞지 않다면 교환한다.
    2. 1회전이 끝나면, 가장 큰 원소가 제일 뒤로 이동하게 된다. 2회전을 수행할 때는 제일 마지막 원소는 제외되고, 그 중 가장 큰 원소가 끝에서 2번째에 위치하게 된다. 이렇게 회전을 계속 수행하며 정렬해 나가게 된다.
* 이해가 쉬운 이미지
    <img src="https://github.com/GimunLee/tech-refrigerator/raw/master/Algorithm/resources/bubble-sort-001.gif"></img>
    * 출처: https://github.com/GimunLee/tech-refrigerator/blob/master/Algorithm/resources/bubble-sort-001.gif
* 공간 복잡도: **O(n)**
* 시간 복잡도: **O(n<sup>2</sup>)**
    * Best: O(n<sup>2</sup>)
    * Avg:  O(n<sup>2</sup>)
    * Worst: O(n<sup>2</sup>)
- Stable
- in-place
### 2. Selection Sort(선택 정렬)
* 가장 작은 것을 선택해 맨 앞의 데이터와 바꾸는 것을 반복하는 알고리즘
    * 순환하면서 최소 or 최대 값을 찾아 현재 원소 위치와 교환하는 방식
* 공간 복잡도: **O(n)**
* 시간 복잡도: **O(n<sup>2</sup>)**
- Unstable
- In-place
### 3. Insertion Sort(삽입 정렬)
* 데이터를 특정한 위치에 삽입한다는 의미에서 "삽입 정렬"이라고 한다
* 2번째 원소부터 시작하여 그 앞(왼쪽)의 원소들과 비교하여 삽입할 위치를 지정한 후, 원소를 뒤로 옮기고 지정된 자리에 자료를 삽입한다
* 공간 복잡도: **O(n)**
* 시간 복잡도: **O(n<sup>2</sup>)**
    * Best: **O(n)**
        - 이미 정렬되어 있는 경우 O(n)의 시간을 가진다.
    * Avg:  O(n<sup>2</sup>)
    * Worst: O(n<sup>2</sup>)
- Stable
- In-place
- 이미 어느정도 정렬되어 있는 경우, 매우 효율적
### 4. Quick Sort
- pivot을 정하여 pivot보다 작은 원소는 왼쪽으로, 큰 원소는 오른쪽으로 하여, 다시 왼쪽부분과 오른쪽 부분에 대하여 각각 반복하는 방식
- 분할 정복 방식이다
* 공간 복잡도: **O(n)**
* 시간 복잡도: **O(nlogn)**
    * Best: O(nlogn)
    * Avg:  O(nlogn)
        - 깊이: logn
        - 비교 연산: n
    * Worst: **O(n<sup>2</sup>)**
- Unstable
- In-place
- 리스트가 계속 불균형하게 나누어지는 경우 (특히, 이미 정렬된 리스트에 대하여 퀵 정렬을 실행하는 경우) O(n<sup>2</sup>)을 가진다.
    - 깊이: n
    - 비교 연산: n
### 5. Merge Sort
### 6. Heap Sort
### 7. Radix Sort
### 8. Counting Sort(계수 정렬)
* 아래 제약사항 아래에서 매우 빠르게 동작하는 알고리즘
    - 데이터(값)은 양수여야 한다.
    - 값의 범위가 너무 크지 않아야 한다.(메모리 사이즈를 넘어서는 안된다.)
* 비교 기반의 알고리즘이 아니다
* 별도의 리스트를 선언하고 데이터를 읽으며 count(계수)를 증가시켜 표시한 후, 해당 리스트의 정보를 이용하여 출력하는 알고리즘
* 방법
    1. 리스트의 인덱스가 데이터의 모든 범위를 포함할수 있도록 선언한다
    2. 데이터를 읽으며 해당 데이터의 값과 동일한 index의 데이터를 1씩 증가시킨다.
        - 결과적으로 리스트에는 각 데이터가 몇 번 등장했는지 그 횟수가 기록된다
    3. 정렬된 결과 확인을 위해, 리스트의 첫번째 데이터부터 하나씩 인덱스 값만큼 출력하면 된다.
* 공간 복잡도: **O(n + k)**
* 시간 복잡도: **O(n + k)**
    - n: 데이터 개수, k: 데이터 중 가장 큰 수
* 일반적으로 가장 큰 데이터와 가장 작은 데이터의 차이가 1,000,000 이하일 때 매우 유용하다
